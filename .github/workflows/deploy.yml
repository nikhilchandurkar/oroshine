name: Deploy to Production

on:
  workflow_run:
    workflows: ["Build Docker Image"]
    branches: [ main, master ]
    types: [ completed ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

jobs:
  check-build:
    name: Check Build Status
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
    
    steps:
      - name: Check if build succeeded
        id: check
        run: |
          # For manual dispatch, always deploy
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For workflow_run, check if build succeeded
          if [ "${{ github.event.workflow_run.conclusion }}" == "success" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Build succeeded. Proceeding with deployment."
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚ùå Build failed. Skipping deployment."
          fi

  deploy:
    name: Deploy to EC2 
    runs-on: ubuntu-latest
    needs: check-build
    if: needs.check-build.outputs.should_deploy == 'true'
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: https://${{ secrets.DOMAIN }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-info
          path: artifacts/
        continue-on-error: true

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file
        run: |
          cat > .env.deploy <<EOF
          # Django Core
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          DEBUG=False
          DJANGO_SETTINGS_MODULE=oroshine.settings
          ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}
          SITE_ID=${{ secrets.SITE_ID }}
          
          # Database
          DATABASE_ENGINE=django.db.backends.postgresql
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          DATABASE_USER=${{ secrets.DATABASE_USER }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_HOST=postgres
          DATABASE_PORT=5432
          
          # Redis
          REDIS_HOST=redis
          REDIS_PORT=${{ secrets.REDIS_PORT }}
          REDIS_DB=${{ secrets.REDIS_DB }}
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # Celery
          CELERY_BROKER_URL=${{ secrets.CELERY_BROKER_URL }}
          CELERY_RESULT_BACKEND=${{ secrets.CELERY_RESULT_BACKEND }}
          
          # Docker
          DOCKER_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          DOCKER_IMAGE_NAME=oroshine
          IMAGE_TAG=${{ github.sha }}
          
          # Gunicorn
          GUNICORN_WORKERS=2
          GUNICORN_THREADS=2
          LOG_LEVEL=info
          
          # Email
          EMAIL_BACKEND=${{ secrets.EMAIL_BACKEND }}
          EMAIL_HOST=${{ secrets.EMAIL_HOST }}
          EMAIL_PORT=${{ secrets.EMAIL_PORT }}
          EMAIL_USE_TLS=${{ secrets.EMAIL_USE_TLS }}
          EMAIL_HOST_USER=${{ secrets.EMAIL_HOST_USER }}
          EMAIL_HOST_PASSWORD=${{ secrets.EMAIL_HOST_PASSWORD }}
          
          # Google Calendar
          GOOGLE_CALENDAR_ID=${{ secrets.GOOGLE_CALENDAR_ID }}
          GOOGLE_CLIENT_CERT_URL=${{ secrets.GOOGLE_CLIENT_CERT_URL }}
          GOOGLE_CLIENT_EMAIL=${{ secrets.GOOGLE_CLIENT_EMAIL }}
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_PRIVATE_KEY=${{ secrets.GOOGLE_PRIVATE_KEY }}
          GOOGLE_PRIVATE_KEY_ID=${{ secrets.GOOGLE_PRIVATE_KEY_ID }}
          GOOGLE_PROJECT_ID=${{ secrets.GOOGLE_PROJECT_ID }}
          
          # AWS S3 (if configured)
          USE_S3=${{ secrets.USE_S3 }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_STORAGE_BUCKET_NAME=${{ secrets.AWS_STORAGE_BUCKET_NAME }}
          AWS_S3_REGION_NAME=${{ secrets.AWS_S3_REGION_NAME }}
          
          EOF

      - name: Copy files to server
        run: |
          # Copy deployment files to server
          scp -i ~/.ssh/deploy_key -r \
            docker-compose.yml \
            nginx/ \
            .env.deploy \
            ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/${{ secrets.SSH_USER }}/oroshine/

      - name: Deploy with zero-downtime strategy
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e
            cd /home/${{ secrets.SSH_USER }}/oroshine
            
            echo "üöÄ Starting deployment..."
            
            # Move .env file
            mv .env.deploy .env
            
            # Login to Docker Hub
            echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            
            # Pull latest image
            echo "üì• Pulling latest Docker image..."
            docker-compose pull web
            
            # Health check function
            check_health() {
              for i in {1..30}; do
                if curl -f http://localhost/health/ >/dev/null 2>&1; then
                  echo "‚úÖ Health check passed"
                  return 0
                fi
                echo "‚è≥ Waiting for service... ($i/30)"
                sleep 2
              done
              echo "‚ùå Health check failed"
              return 1
            }
            
            # Create backup of current state
            echo "üíæ Creating backup..."
            docker-compose ps > deployment-backup-$(date +%Y%m%d-%H%M%S).txt
            
            # Zero-downtime deployment strategy
            echo "üîÑ Starting rolling update..."
            
            # Start new containers with different name
            docker-compose up -d --no-deps --scale web=2 --no-recreate web
            
            # Wait for new container to be healthy
            sleep 10
            
            # Remove old containers
            docker-compose up -d --no-deps --scale web=1 --remove-orphans
            
            # Restart nginx to ensure routing is correct
            docker-compose restart nginx
            
            # Final health check
            if check_health; then
              echo "‚úÖ Deployment successful!"
              
              # Cleanup old images (keep last 3)
              docker image prune -af --filter "until=720h"
              
              # Show running containers
              docker-compose ps
            else
              echo "‚ùå Deployment failed! Rolling back..."
              
              # Rollback by restarting with old image
              docker-compose down
              docker-compose up -d
              
              exit 1
            fi
            
            echo "üìä Deployment Summary:"
            echo "  Image: ${{ secrets.DOCKER_USERNAME }}/oroshine:${{ github.sha }}"
            echo "  Commit: ${{ github.sha }}"
            echo "  Branch: ${{ github.ref_name }}"
            echo "  Time: $(date)"

      - name: Run smoke tests
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            echo "üß™ Running smoke tests..."
            
            # Test health endpoint
            curl -f http://localhost/health/ || exit 1
            
            # Test static files
            curl -f http://localhost/static/admin/css/base.css >/dev/null 2>&1 || echo "‚ö†Ô∏è  Static files may not be served correctly"
            
            # Check database connectivity
            docker-compose exec -T web python manage.py check --database default || exit 1
            
            echo "‚úÖ All smoke tests passed!"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to ${{ github.event.inputs.environment || 'production' }} successful!"
            echo "üåê URL: https://${{ secrets.DOMAIN }}"
            echo "üì¶ Version: ${{ github.sha }}"
          else
            echo "‚ùå Deployment failed!"
          fi

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f .env.deploy

  post-deploy:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    
    steps:
      - name: Create GitHub deployment
        uses: chrnorm/deployment-action@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          environment: ${{ github.event.inputs.environment || 'production' }}
          environment-url: https://${{ secrets.DOMAIN }}

      - name: Notify team (Slack/Discord/etc)
        run: |
          # Add your notification logic here
          echo "üì¢ Notifying team about deployment..."
          # Example: curl -X POST -H 'Content-type: application/json' --data '{"text":"Deployment successful!"}' ${{ secrets.SLACK_WEBHOOK }}

  deploy-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [check-build, deploy, post-deploy]
    if: always()
    
    steps:
      - name: Deployment summary
        run: |
          echo "üöÄ Deployment Summary"
          echo "===================="
          echo "Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "Build Check: ${{ needs.check-build.result }}"
          echo "Deploy: ${{ needs.deploy.result }}"
          echo "Post-Deploy: ${{ needs.post-deploy.result }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Triggered by: ${{ github.event_name }}"
          
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "‚úÖ Deployment completed successfully!"
          else
            echo "‚ùå Deployment failed!"
            exit 1
          fi